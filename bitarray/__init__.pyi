from abc import ABC, abstractmethod
from typing import Any, List, Iterator, Tuple, Iterable, TypeVar, IO, Union, Optional

from bitarray._bitarray import _bitarray

class SupportsBool(ABC):
    @abstractmethod
    def __bool__(self) -> bool:
        pass

class bitarray(_bitarray):
    def fromstring(self, string: str) -> None: ...
    def tostring(self) -> str: ...
    def decode(self, codedict: Any) -> List: ...
    def iterdecode(self, codedict: Any) -> Iterator: ...
    def encode(self, codedict: Any, iterable: Any) -> None: ...
    def __int__(self) -> int: ...
    def __long__(self) -> int: ...
    def __float__(self) -> float: ...

    # _bitarray functions
    def all(self) -> bool: ...
    def any(self) -> bool: ...
    def append(self) -> None: ...
    def buffer_info(self) -> Tuple[int, int, int, int, int]: ...
    def bytereverse(self) -> None: ...
    def copy(self) -> bitarray: ...
    def count(self, value=bool) -> int: ...
    def endian(self) -> str: ...
    def extend(self, p_object): ...  # TODO
    def fill(self) -> int: ...
    def frombytes(self, bytes: bytes): ...
    def fromfile(self, f: IO, n: Optional[int] = None): ...
    def index(self, value: SupportsBool, start:Optional[int]=None, stop:Optional[int]=None) -> int: ...
    def insert(self, i: int, item: SupportsBool): ...
    def invert(self) -> None: ...
    def itersearch(self, bitarray: _bitarray) -> Iterator[int]: ...
    def length(self) -> int: ...
    def pack(self, bytes: bytes) -> None: ...
    def pop(self, i: Optional[int]=None): ...
    def remove(self, item: SupportsBool): ...
    def reverse(self): ...
    def search(self, bitarray: _bitarray, limit: int=Optional[None]): ...
    def setall(self, value:SupportsBool): ...
    def sort(self, reverse:bool =False): ...
    def to01(self) -> str: ...
    def tobytes(self) -> bytes: ...
    def tofile(self, f: IO) -> None: ...
    def tolist(self) -> List[bool]: ...
    def unpack(self, zero: Optional[bytes]=None, one: Optional[bytes]=None, *args, **kwargs) -> bytes: ...
    def _decode(self, tree) -> List: ...
    def _encode(self, code, iterable: Iterable): ...
    def _iterdecode(self, tree) -> List: ...
    def __add__(self, *args, **kwargs) -> bitarray: ...
    def __and__(self, *args, **kwargs) -> bitarray: ...
    def __contains__(self, x: Union[SupportsBool, bitarray]) -> bool: ...
    def __copy__(self, *args, **kwargs) -> bitarray: ...
    def __deepcopy__(self, *args, **kwargs) -> bitarray: ...
    def __delitem__(self, *args, **kwargs) -> None: ...
    def __eq__(self, *args, **kwargs) -> bool: ...
    def __getattribute__(self, *args, **kwargs): ...  # todo
    def __getitem__(self, *args, **kwargs): ...
    def __ge__(self, *args, **kwargs): ...
    def __gt__(self, *args, **kwargs): ...
    def __iadd__(self, *args, **kwargs): ...
    def __iand__(self, *args, **kwargs): ...
    def __imul__(self, *args, **kwargs): ...
    def __init__(self, *args, **kwargs): ...
    def __invert__(self, *args, **kwargs): ...
    def __ior__(self, *args, **kwargs): ...
    def __iter__(self, *args, **kwargs): ...
    def __ixor__(self, *args, **kwargs): ...
    def __len__(self) -> int: ...
    def __le__(self, *args, **kwargs) -> bool: ...
    def __lt__(self, *args, **kwargs) -> bool: ...
    def __mul__(self, *args, **kwargs): ...
    def __new__(*args, **kwargs): ...
    def __ne__(self, *args, **kwargs) -> bool: ...
    def __or__(self, *args, **kwargs) -> bool: ...
    def __reduce__(self, *args, **kwargs):  ...
    def __repr__(self, *args, **kwargs) -> str: ...
    def __rmul__(self, *args, **kwargs): ...
    def __setitem__(self, *args, **kwargs): ...
    def __xor__(self, *args, **kwargs): ...
